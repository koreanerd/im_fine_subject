## 목차

- [과제 목표 및 달성 현황](#과제-목표-및-달성-현황)
- [프로젝트 구조](#프로젝트-구조)
- [데모](#데모)
- [주요 개발과정 고민](#주요-개발과정-고민)
- [과제 분석](#과제-분석)
  - [1. 출제 의도 해석](#1-출제-의도-해석)
  - [2. 핵심 기능 / 요구사항](#2-핵심-기능--요구사항)
- [설계 개요](#설계-개요)
  - [1. 디자인 패턴 설정](#1-디자인-패턴-설정)
  - [2. 패턴별 비교 및 선택 근거](#2-패턴별-비교-및-선택-근거)
  - [3. 시스템 아키텍처 설계](#3-시스템-아키텍처-설계)
  - [4. 데이터 모델(State) 설계](#4-데이터-모델state-설계)
  - [5. 주요 컴포넌트 / 모듈 역할 분담](#5-주요-컴포넌트--모듈-역할-분담)
  - [6. 데이터 흐름 및 리렌더링 프로세스](#6-데이터-흐름-및-리렌더링-프로세스)
  - [7. 설계 최종 요약 및 기대 효과](#7-설계-최종-요약-및-기대-효과)

## 과제 목표 및 달성 현황

**최소 개발 요건**

- 이름 표기

  - [✔] ~~우측 최상단에 이름 기제하기~~

- 그래프

  - [✔] ~~- 하단에 구현될 각종 컨트롤러의 값을 그래픽 차트로 표현~~

- 값 편집

  - [✔] ~~표 형식으로 기존 추가 되었던 값을 편집 하거나 삭제 할 수 있음~~
  - [✔] ~~아이디는 편집 할 수 없으며, 값만 바꿀 수 있다.~~
  - [✔] ~~Apply 버튼 클릭시 연관된 모든 컴포넌트들이 동시에 업데이트 됨~~

- 값 추가

  - [✔] ~~새로운 값을 입력 하여 추가 할 수 있음~~
  - [✔] ~~Add 버튼 클릭시 연관된 모든 컴포넌트들이 동시에 업데이트 됨~~

- 값 고급 편집
  - [✔] ~~2~3번 에서 수정한 내용이 그대로 텍스트박스에 갱신 됨~~
  - [✔] ~~사용자가 직접 JSON을 편집 할 수 있으며, Apply 버튼 클릭시 연관된 모든 컴포넌트들이 동시에 업데이트 됨~~

## 프로젝트 구조

```bash
📂 root
├── 📂 public
│   └── index.html                # 기본 DOM 구조 및 자바스크립트 번들 연결 위치
├── README.md
└── 📂 src                        # 모든 소스 코드가 위치하는 메인 디렉터리
    ├── 📂 components             # UI 컴포넌트 렌더링 관련 모듈들을 모아둔 폴더
    │   ├── chartRenderer.js      # 막대 그래프 렌더링 및 툴팁 표시 담당
    │   ├── jsonEditorRenderer.js # JSON 편집기 렌더링 및 Apply 처리
    │   └── tableRenderer.js      # 테이블 UI 생성 및 데이터 수정/삭제/적용 기능
    ├── 📂 core                   # 비즈니스 로직 및 상태 관리의 중심이 되는 핵심 모듈
    │   ├── formHandler.js        # 폼 입력 처리 및 유효성 검사, 상태 갱신
    │   ├── idManager.js          # 고유 ID 발급 및 로컬스토리지 동기화 담당
    │   └── state.js              # 앱의 전역 상태 관리 (옵저버 패턴 + 로컬스토리지)
    ├── 📂 layout                 # 레이아웃 관련 구성 요소 (DOM 구조 세팅 등)
    │   └── createLayout.js       # 초기 레이아웃 생성 (chart, table, editor, form 배치)
    ├── main.js                   # 앱 초기화, 상태 구독, 렌더러 통합 등 전체 진입 스크립트
    ├── 📂 styles                 # CSS 관련 파일을 모은 폴더
    │   └── index.css             # 전체 UI의 스타일을 정의하는 메인 CSS 파일
    └── 📂 utils                  # 범용적으로 재사용되는 유틸리티 함수 모음
        └── utils.js              # DOM 생성 등 반복 로직 추출 (ex: createTextElement)

```
## 데모
![May-01-2025 12-26-18](https://github.com/user-attachments/assets/24e0bb6d-8fc0-47da-aa17-80dce7fc7888)


## 주요 개발과정 고민

### **ID 관리 전략의 고민**

- **처음에는 `localStorage`를 활용한 전역 `idCounter` 방식**을 사용하여 순차적인 번호 부여함.
- 그러나 JSON 편집기나 테이블에서 데이터를 무작위 삭제했을때 ID 순서가 보장되지 않거나 중복 아이디가 생성됨.
- 최종적으로는 **배열 순서를 기반으로 ID를 자동 재생성하고, 상태에 따라 `idCounter`를 동기화**하는 방식으로 수정함.

📌 **결론**:

> 고유한 식별자는 사용자가 직접 관리하면 안 되며, 시스템이 상태 기반으로 일관성 있고 중복이 없게 생성해야 한다는 점을 다시한번 확인할 수 있었습니다.

### CSS 구성 전략의 변화

- 개발 초반에는 컴포넌트별 CSS 분리를 고려했음.
- 과제의 의도와 평가 방식(GitHub에서 하나의 HTML로 실행) 그리고 성능 및 로딩 효율 등을 감안해
  단일 CSS 파일(index.css) 로 통합하는 방향으로 결정.

📌 **결론**:

> 컴포넌트 단위 분리는 유지보수엔 좋지만, 모든 상황에서 최선은 아니라고 생각합니다. 요구사항과 맥락에 따라 적절한 수준의 구조화가 오히려 더 실용적일때도 있다는 것을 알 수 있었습니다.

### 리팩터링 기준에 대한 고찰

- 과거에는 코드가 길어지거나 복잡해질 경우 무조건 파일을 분리하는 방식을 선택함.
- 이번 과제에서는 '**사용 범위와 재사용 가능성**'을 중심으로 리팩터링 기준을 다음과 같이 정립:

  - 한 파일 내부에서만 사용되고, 재사용 가능성도 낮은 기능이라면 굳이 별도 파일로 분리하지 않고 해당 컨텍스트 안에서 관리한다.

    - 예: chartRenderer.js 내부의 툴팁 로직 → 컴포넌트 외부에서 쓰이지 않기 때문에 내부에 그대로 유지.

  - '**여러 곳에서 사용되거나 재사용 가능성이 있다면**' 분리한다.

    - 예: createTextElement()와 같은 유틸성 함수는 다양한 컴포넌트에서 쓰이므로 utils.js로 분리.

  - 분리로 인해 오히려 복잡성이 증가하지 않아야 한다.
    - 분리된 파일이 너무 많아져서 관리나 흐름 파악이 어렵다면, 오히려 가독성과 유지보수성을 해치는 결과로 이어질 수 있음.

📌 **결론**:

> 파일을 나누는 기준은 길이나 양이 아니라 맥락과 재사용성을 기준으로 해야합니다. 꼭 나눠야 할 이유가 없다면 한 곳에 모아두는 것이 오히려 명확하고 효율적일 수 있기 때문입니다. 또한 제한된 시간내에 개발을 해야한다면 초기부터 재사용 로직을 고민하는 것은 업무의 강도를 높일 수 있다고 생각하였습니다.

## 과제 분석

### 1. 출제 의도 해석

> 해당 과제는 단순한 기능 구현을 넘어, 순수 HTML, CSS, JavaScript만을 사용하여 개발자의 기본적인 소프트웨어 설계 능력과 프로그래밍 감각을 평가하는 데 목적이 있다고 판단하였습니다. React나 Vue 같은 프레임워크의 자동화된 데이터 바인딩이나 컴포넌트 시스템 없이 제작해야 하는 이유는, 스스로 데이터 흐름을 설계하고 DOM 업데이트를 명확히 관리할 수 있는지 검증하려는 것이라고 생각했습니다.
>
> 과제는 표, 그래프, JSON 편집기처럼 영역을 나누어 관리해야 하며, 이 각각의 기능들은 하나의 상태(state)를 중심으로 유기적으로 연결되고 동기화되어야 합니다. 또한 빌드 도구나 별도의 라이브러리 없이, index.html, index.css, main.js 파일만으로 브라우저에서 바로 실행 가능한 구조를 요구하며, 이는 현대 웹 개발이 추구하는 경량화와 최소 구성의 개발 능력을 함께 평가하려는 의도가 담겨 있다고 판단 됩니다.
>
> 평가 기준은 절대평가(요구 기능의 충족 여부)와 상대평가(코드 품질, 사용성, 창의성)를 병행하여, 단순히 기능을 완성하는 데 그치지 않고, 얼마나 깔끔하고 유지보수 가능한 구조를 설계했는지를 함께 봅니다.
>
> 결국 이 과제는 바닐라 자바스크립트만으로 컴포넌트 구조를 직접 설계하고, 데이터와 UI를 일관성 있게 관리할 수 있는 기본기와 함께 개발자로서의 사고력과 프로그래밍 감각까지 종합적으로 평가하는 문제라고 할 수 있습니다.

### 2. 핵심 기능 / 요구사항

> 본 과제는 사용자 입력을 기반으로 데이터를 관리하고, 이를 다양한 UI 요소를 통해 시각적으로 표현하며, 모든 데이터 변경 사항을 통합적으로 반영하는 어플리케이션을 구현하는 것을 목표로 합니다.
>
> 각 기능은 아래와 같은 세부 요건을 충족해야 합니다.

#### 📊 **그래프**

- 그래프는 사용자가 입력하거나 수정한 데이터를 막대 차트 형태로 시각화합니다.
- 막대의 길이는 값(value)을 기준으로 표현하며, 값은 0부터 100까지의 범위를 가집니다.
- 데이터가 추가되거나 수정될 때, 그래프 역시 최신 상태를 반영하여 갱신되어야 합니다.

---

#### 📝 **값 편집 (테이블)**

- 기존 데이터는 테이블 형태로 표시되며, 각 행(row)은 ID, 값(Value), 삭제(Delete) 버튼으로 구성됩니다.
- 사용자는 테이블에서 값을 직접 수정할 수 있으며, 수정된 값은 Apply 버튼을 통해 적용할 수 있습니다.
- ID는 생성 시 자동으로 부여되며, 수정은 허용되지 않습니다.
- Apply 버튼을 클릭하면 그래프, 값 편집 테이블, JSON 편집기에 반영된 모든 데이터가 동시에 갱신되어야 합니다.

---

#### ➕ **값 추가**

- 사용자는 새로운 Label과 Value를 입력하여 데이터를 추가할 수 있습니다.
- 추가된 데이터는 고유한 ID를 자동으로 부여받으며, Add 버튼을 클릭하여 등록합니다.
- Add 버튼을 누르면 그래프, 값 편집 테이블, JSON 편집기에 반영된 모든 데이터가 즉시 갱신되어야 합니다.

---

#### 🧩 **값 고급 편집 (JSON 편집기)**

- 전체 데이터는 JSON 형식으로 표시되며, 사용자는 이를 직접 편집할 수 있습니다.
- 텍스트 박스에는 현재 데이터 상태가 자동으로 반영되어 표시되며, 수정을 통해 데이터 일괄 변경이 가능합니다.
- JSON 편집기는 문법 오류 없이 정확한 JSON 형태를 유지해야 하며, 잘못된 형식 입력 시 오류를 방지해야 합니다.
- Apply 버튼을 클릭하면 수정된 JSON 데이터가 적용되며, 그래프, 값 편집 테이블, JSON 편집기에 반영된 모든 데이터가 동시에 최신화되어야 합니다.

## 설계 개요

### 1. 디자인 패턴 설정

> 본 과제는 모든 인터페이스가 하나의 상태를 기준으로 동기화되고, 상태가 바뀔 때마다 모든 UI 요소가 자동으로 반응해야 하는 요구사항을 가지고 있습니다. 이런 구조를 효율적으로 만들기 위해 적합한 패턴은 **옵저버 패턴**(Observer Pattern)이라는 결정을 내렸습니다.
>
> 또한, 상태를 관리하는 객체는 어플리케이션 전역에서 일관되게 하나만 유지되어야 하니, 싱글톤 패턴(Singleton Pattern) 을 도입하였습니다. 이를 통해 여러 모듈이 동일한 상태를 참조하면서도 충돌 없이 일관된 데이터 흐름을 유지할 수 있습니다.

### 2. 패턴별 비교 및 선택 근거

> 본 과제는 소규모 데이터 관리와 UI 동기화가 핵심이므로, **중앙 상태 관리 + 옵저버 패턴 기반 설계** 가 가장 단순하고 강력한 해법이라고 생각했습니다. 따라서, 복잡성을 초래할 수 있는 패턴 사용은 지양 했습니다.

#### 📋 패턴별 특징 비교표

| 패턴             | 적용성                | 결론                                             |
| ---------------- | --------------------- | ------------------------------------------------ |
| 옵저버 패턴      | ✅ 적극 적용          | 상태 변화 감지 및 UI 리렌더링에 가장 적합        |
| MVC 패턴         | 🔵 구조적 분리는 참고 | 현재 과제 규모에서는 명시적 적용은 과도하여 생략 |
| 커맨드 패턴      | ❌ 적용 불필요        | 명령 이력 관리 필요가 없어 과제 범위 초과        |
| 이벤트 기반 설계 | ❌ 적용 불필요        | 이벤트 복잡도 증가, 현재 요구사항에 비효율적     |
| 싱글톤 패턴      | 🔵 자연스럽게 적용    | 상태 객체의 일관성 유지를 위해 필수              |

### 3. 시스템 아키텍처 설계

> 본 과제는 중앙 상태(appState)를 기준으로, 여러 UI 컴포넌트들이 상태 변화를 감지하고 동기화되는 구조로 설계하였습니다.
>
> 이를 통해 하나의 일관된 데이터 흐름을 유지하면서 그래프, 값 편집의 테이블, 값 추가의JSON 텍스트박스 각각이 독립적으로 상태를 반영할 수 있도록 구성하였습니다.

#### 📐 전체 구조 개요

- **`appState`**
  - 어플리케이션 전역에서 데이터를 관리하는 단일 상태 객체입니다.
- **Observer(옵저버) 구조**
  - 각 UI 컴포넌트는 appState에 구독(subscribe)되어 있으며,
  - 상태가 변경될 때마다 자동으로 본인에게 필요한 렌더링을 수행합니다.
- UI 컴포넌트 분류
  - **그래프(Chart)**: 데이터를 시각적으로 막대 차트 형태로 표시
  - **테이블(Table)**: 데이터 목록을 표 형태로 편집, 삭제 가능
  - **JSON 편집기(JSON Editor)**: 데이터를 JSON 형식으로 고급 편집

---

#### 🗺️ 시스템 흐름 요약

1. 사용자가 테이블, JSON 에디터, 값 추가 폼 등을 통해 데이터를 수정하거나 추가한다.
2. 수정/추가된 데이터는 appState에 반영된다.
3. appState의 변경이 감지되면, 구독하고 있던 모든 렌더링 함수(`chartRenderer`, `tableRenderer`, `jsonEditorRenderer`)가 호출된다.
4. 각 UI는 새로운 상태를 기준으로 화면을 다시 그린다.

---

#### 🎯 설계 의도 요약

- **중앙 집중식 데이터 관리**를 통해 상태 일관성을 유지합니다.
- **옵저버 패턴**을 활용하여 데이터 변경에 따른 UI 반영을 자동화합니다.
- **모듈별 역할을 분리**하여 유지보수성과 확장성을 고려합니다.

### 4. 데이터 모델(State) 설계

> 본 과제는 하나의 중앙 상태(appState)를 통해 모든 UI 요소를 동기화하기 때문에, 데이터 모델의 구조를 명확하게 설계하는 것이 중요합니다.
>
> 데이터는 각 항목이 고유한 ID와 사용자 정의 Label, 값(Value)을 가지는 객체(Object) 형태로 구성됩니다.

#### 🗄️ 데이터 구조 정의

```jsx
[
  { id: 1, label: "Sample 1", value: 30 },
  { id: 2, label: "Sample 2", value: 75 },
  { id: 3, label: "Sample 3", value: 50 },
  ...
]
```

| 필드    | 타입   | 설명                                            |
| ------- | ------ | ----------------------------------------------- |
| `id`    | Number | 각 항목을 고유하게 식별하기 위한 ID (자동 부여) |
| `label` | String | 항목의 이름 또는 설명 (사용자 입력 기반)        |
| `value` | Number | 항목의 수치값 (0~100 범위, 그래프에 반영)       |

---

#### 🔎 데이터 관리 규칙

- **ID는 수정 불가**:
  ID는 데이터의 고유성을 보장하기 위해 생성 시 자동으로 부여되며, 이후 수정할 수 없습니다.
- **Label과 Value는 수정 가능**:
  사용자는 테이블이나 JSON 편집기를 통해 label과 value를 자유롭게 수정할 수 있습니다.
- **Value 값 검증**:
  value는 0~100 범위 내의 숫자만 허용됩니다. 범위를 벗어나는 경우 오류를 처리하거나 입력을 제한해야 합니다.
- **데이터 일관성 유지**:
  데이터 수정, 추가, 삭제 시 항상 appState를 갱신하고, 이에 따라 모든 UI를 리렌더링하여 일관성을 유지합니다.

---

#### 🎯 설계 의도 요약

- **간결하고 직관적인 데이터 구조**를 통해 상태 관리와 렌더링 효율성을 높였습니다.
- **명확한 필드 정의와 관리 규칙**을 설정하여, 개발 중 데이터 무결성(data integrity)을 쉽게 유지할 수 있도록 하였습니다.

### 5. 주요 컴포넌트 / 모듈 역할 분담

> 본 과제는 각 UI 요소별로 명확한 역할을 분리하여 설계함으로써, 코드의 가독성과 유지보수성을 높이고자 하였습니다.
>
> 각 모듈은 appState를 구독(subscribe)하고, 필요에 따라 데이터를 읽거나 수정하는 책임을 가집니다.

#### 🧩 주요 컴포넌트 및 모듈 목록

| 컴포넌트/모듈           | 역할                                                               |
| ----------------------- | ------------------------------------------------------------------ |
| `main.js`               | 애플리케이션 진입점, 초기 렌더링 실행 및 주요 이벤트 핸들러 바인딩 |
| `state.js`              | 중앙 상태(appState) 관리, 상태 변경 감지 및 옵저버(구독자) 통지    |
| `chartRenderer.js`      | appState를 기반으로 막대 차트를 생성 및 업데이트                   |
| `tableRenderer.js`      | appState를 기반으로 테이블 생성, 값 수정 및 삭제 기능 제공         |
| `jsonEditorRenderer.js` | appState를 JSON 형식으로 변환하여 편집기 표시 및 수정 반영         |
| `formHandler.js`        | 새 데이터를 추가하는 폼(Add Form) 관리, 입력 검증 및 상태 업데이트 |
| `utils.js` _(선택적)_   | 공통 기능(예: ID 자동 생성, 입력 검증 함수 등)을 유틸리티로 분리   |

---

#### 🛠️ 각 모듈의 구체적 기능

- **main.js**
  - DOMContentLoaded 시 초기 렌더링 실행
  - 이벤트 리스너 설정 (Add 버튼, Apply 버튼 등)
  - 사용자의 입력/편집 동작을 캡처하여 적절한 핸들러로 전달
- **state.js**
  - `appState` 객체 보관
  - `getState()`, `setState(),` `subscribe()` 등의 메서드를 제공
  - `setState` 호출 시 자동으로 구독자 함수들 호출 (렌더링 트리거)
- **chartRenderer.js**
  - 현재 `appState` 데이터를 기반으로 막대 차트 DOM 생성
  - 값(value)을 기준으로 막대 길이를 시각적으로 표현
- **tableRenderer.js**
  - `appState`를 표 형태로 변환하여 렌더링
  - 행 단위로 값 수정, 삭제 기능 제공
  - Apply 버튼을 통한 수정사항 반영 처리
- **jsonEditorRenderer.js**
  - `appState` 전체를 JSON 문자열로 변환하여 표시
  - 사용자가 JSON을 직접 수정 후 Apply 버튼 클릭 시 `appState` 갱신
- **formHandler.js**
  - Add Form 입력값(`label`, `value`) 검증
  - 새 데이터 객체 생성 및 `appState`에 추가
- **utils.js** _(선택사항)_
  - ID 자동 생성 함수
  - 입력값 숫자 범위(0~100) 검증 함수
  - JSON 포맷 유효성 검사 등 공통 로직 분리

---

#### 🎯 설계 의도 요약

- 각 모듈은 **단일 책임 원칙(SRP)** 에 따라 하나의 명확한 역할만 담당합니다.
- 공통 로직은 utils.js에 분리하여 **재사용성과 유지보수성**을 높입니다.
- 모든 렌더링과 데이터 변경은 **`appState`를 통한 흐름**으로 일관되게 처리합니다.

## 6. 데이터 흐름 및 리렌더링 프로세스

> 본 과제는 모든 데이터 변경(Add, Edit, Delete, JSON 수정 등)이 중앙 상태(`appState`)를 통해 일관되게 관리되고, 상태가 변경될 때마다 자동으로 모든 UI 요소(그래프, 테이블, JSON 편집기)가 최신 상태를 반영하도록 설계되었습니다.

#### 🔄 전체 데이터 흐름 요약

1. 사용자가 UI를 통해 데이터 수정, 추가, 삭제를 시도한다.
2. 해당 동작은 이벤트 핸들러를 통해 `appState`에 변경을 요청한다.
3. `appState`의 `setState()`가 호출되면서 내부 데이터가 갱신된다.
4. `setState()`는 등록된 모든 렌더링 함수(옵저버)들에게 알림(notify)을 보낸다.
5. 각 렌더링 함수(`chartRenderer`, `tableRenderer`, `jsonEditorRenderer`)는 최신 `appState`를 기반으로 화면을 다시 그린다.

---

#### ⚙️ 주요 동작별 상세 흐름

| 동작                   | 처리 흐름                                                                                                            |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------- |
| **값 추가(Add)**       | 사용자가 폼에 Label, Value 입력 → Add 버튼 클릭 → 새로운 데이터 객체 생성 → `appState`에 추가 → 모든 UI 리렌더링     |
| **값 수정(Edit)**      | 사용자가 테이블 셀에서 Value 수정 → Apply 버튼 클릭 → 수정된 값으로 `appState` 업데이트 → 모든 UI 리렌더링           |
| **값 삭제(Delete)**    | 사용자가 테이블의 Delete 버튼 클릭 → 해당 항목을 `appState`에서 제거 → 모든 UI 리렌더링                              |
| **JSON 편집 후 Apply** | 사용자가 JSON 에디터에서 데이터 수정 → Apply 버튼 클릭 → 수정된 JSON을 `appState`로 변환하여 반영 → 모든 UI 리렌더링 |

---

#### 🧠 데이터 일관성 유지 전략

- 모든 데이터 수정은 반드시 **`appState`를 경유**하여 이루어집니다.
- 직접 DOM을 조작하지 않고, 항상 **`appState` → 렌더링** 흐름을 고수합니다.
- 이를 통해 데이터와 화면 사이의 불일치를 방지하고, 코드의 예측 가능성을 높입니다.

---

#### 🎯 설계 의도 요약

- 모든 사용자 액션은 하나의 데이터 흐름(state update → notify → render)을 따릅니다.
- 이로써 코드가 단순하고 명료해지며, 확장성과 유지보수성이 크게 향상됩니다.

### 7. 설계 최종 요약 및 기대 효과

> 본 과제는 중앙 상태(appState)를 기준으로, 모든 데이터 흐름과 UI 렌더링을 일관성 있게 설계하는 것을 목표로 하였습니다.
>
> 이를 위해 옵저버 패턴(Observer Pattern)과 싱글톤 패턴(Singleton Pattern)을 적용하여, 상태 관리와 UI 반영을 자동화하고, 코드 구조의 명료성과 유지보수성을 확보하고자 했습니다.

#### 🧩 최종 설계 요약

- **중앙 집중식 상태 관리**(appState)를 통해 데이터의 일관성과 흐름을 명확히 유지합니다.
- **옵저버 패턴**을 적용하여 상태 변경 시 자동으로 UI가 최신화되는 구조를 구성했습니다.
- **모듈별 역할 분리**를 통해 기능 단위로 코드를 관리하고, 책임을 명확히 구분했습니다.
- **간결하고 직관적인 데이터 모델**을 설계하여 데이터 관리와 변환 과정을 단순화했습니다.
- 표준화된 데이터 흐름(state update → notify → re-render)을 확립하여 시스템의 예측 가능성을 높였습니다.

---

#### 🚀 기대 효과

| 기대 효과                 | 설명                                                                                                        |
| ------------------------- | ----------------------------------------------------------------------------------------------------------- |
| **유지보수성 향상**       | 모듈화된 구조 덕분에 수정/확장이 용이하며, 특정 기능 변경이 다른 부분에 미치는 영향을 최소화할 수 있습니다. |
| **확장성 확보**           | 추가 기능(예: 검색, 필터링, 정렬 등)을 도입할 때에도 일관된 데이터-UI 흐름을 유지할 수 있습니다.            |
| **버그 발생 가능성 감소** | 모든 데이터 변경을 중앙 상태에서 통제하고, 직접 DOM 조작을 피함으로써 예기치 않은 UI 불일치를 방지합니다.   |
| **협업 효율성 증가**      | 역할이 명확하게 분리된 코드베이스 덕분에 여러 개발자가 각 기능을 독립적으로 작업하고 리뷰할 수 있습니다.    |
